<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no">
    <link href="assets/index.css" rel="stylesheet">
    <title>扩展</title>
</head>

<body>
    <section class="es6-wrapper">
        <h1>扩展</h1>
        <div class="content">
            <ul class="con-ul">
                <li class="con-li">
                    1、字符串的扩展
                    <ul class="infos-ul">
                        <li>字符串可以被for...of循环遍历</li>
                        <li>模板字符串</li>
                    </ul>
                </li>
                <li class="con-li">
                    2、数值的扩展
                    <ul class="infos-ul">
                        <li>Number.isFinite()、Number.isNaN()、Number.isInteger()、Math.sign()</li>
                    </ul>
                </li>
                <li class="con-li">
                    3、数组的扩展
                    <ul class="infos-ul">
                        <li>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</li>
                        <li>Array.from()</li>
                        <li>Array.of()</li>
                        <li>数组实例的 find() 和 findIndex() </li>
                        <li>数组实例的 entries()，keys() 和 values()</li>
                        <li>数组实例的 includes()</li>
                    </ul>
                </li>
                <li class="con-li">
                    4、对象
                    <ul class="infos-ul">
                        <li>属性的简洁表示法</li>
                        <li>属性名表达式</li>
                        <li>方法的 name 属性</li>
                        <li>属性的遍历</li>
                        <li>对象的扩展运算符</li>
                    </ul>
                </li>
                <li class="con-li">
                    5、对象增强
                    <ul class="infos-ul">
                        <li>Object.is()</li>
                        <li>Object.assign()</li>
                    </ul>
                </li>
            </ul>
        </div>
    </section>

    <script>
        // 字符串扩展：es6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历
        for (let codepoint of 'bar') {
            console.log(codepoint)
        }
        // 字符串扩展：模板字符串
        var person = { name: 'zhangsan' }
        var str = 'name:' + person.name;
        var str2 = `name:${person.name}`;
        console.log(str, str2);


        // 数值的扩展：Number.isFinite()和Number.isNaN(),Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false
        // Number.isFinite(15); // true
        // Number.isFinite(0.8); // true
        // Number.isFinite(NaN); // false
        // Number.isFinite(Infinity); // false
        // Number.isFinite(-Infinity); // false
        // Number.isFinite('foo'); // false
        // Number.isFinite('15'); // false
        // Number.isFinite(true); // false
        // Number.isNaN(NaN) // true
        // Number.isNaN("NaN") // false
        // Number.isNaN(1) // false
        // Number.isInteger(25) // true
        // Number.isInteger(25.1) // false
        // Math.sign(-5) // -1
        // Math.sign(5) // +1
        // Math.sign(0) // +0
        // Math.sign(-0) // -0
        // Math.sign(NaN) // NaN


        // 数组的扩展：扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
        console.log(...[1, 2, 3]);
        function add(x, y, z) {
            return x + y + z;
        }
        console.log(add(...[1, 2, 3]));

        // 数组的扩展：Array.from()方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象
        let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c',
            length: 3
        };
        let arr2 = Array.from(arrayLike);
        console.log(arr2);
        console.log(Array.from('hello'));

        // 数组的扩展：Array.of()用于将一组值，转换为数组
        Array.of(1, 2, 3);

        // 数组的扩展：数组实例的 find() 和 findIndex() 
        // [1, 4, -5, 10].find((n) => n < 0); // -5
        // [1, 4, -5, 10].findIndex((n) => n < 0); // 2

        // 数组的扩展：数组实例的 entries()，keys() 和 values()
        // for (let index of ['a', 'b'].keys()) {
        //     console.log(index);
        // }
        // for (let elem of ['a', 'b'].values()) {
        //     console.log(elem);
        // }
        // for (let [index, elem] of ['a', 'b'].entries()) {
        //     console.log(index, elem);
        // }

        // 数组的扩展：数组实例的includes()
        // [1, 2, 3].includes(2) // true


        // 对象的扩展：属性的简洁表示法，属性名和属性值如果一致，则可以简写
        // function f(x, y) {
        //     return { x, y };
        // } // 等同于
        // function f(x, y) {
        //     return { x: x, y: y };
        // }
        // const o = {
        //     method() {
        //         return 'hello world';
        //     }
        // } // 等同于
        // const a = {
        //     method: function () {
        //         return 'hello world';
        //     }
        // }

        // 对象的扩展：属性名表达式
        // let lastWord = 'last word';
        // const a = {
        //     'first word': 'hello',
        //     [lastWord]: 'world'
        // };
        // console.log(a['first word'], a[lastWord]);

        // 对象的扩展：方法的name属性
        // const person = {
        //     sayName() {
        //         console.log('hello!');
        //     },
        // };
        // person.sayName.name   // "sayName"

        // 对象的扩展：属性的遍历
        // es6一共有5中方法可以遍历对象的属性
        // for...in  循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
        // Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
        // Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
        // Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
        // Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举

        // 对象的扩展：对象的扩展运算符
        // let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; // z {a:3, b: 4}


        // 对象增强
        // Object.is() 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致
        Object.is('foo', 'foo') // true
        Object.is({}, {}) // false
        // Object.is()和=== 不同之处只有两个：一是+0不等于-0，二是NaN等于自身
        console.log(+0 === -0) //true
        console.log(NaN === NaN) // false
        Object.is(+0, -0) // false
        Object.is(NaN, NaN) // true
        // Object.assign() 用于对象的合并
        const target = { a: 1 };
        const source1 = { b: 2 };
        const source2 = { c: 3 };
        Object.assign(target, source1, source2); // {a:1, b:2, c:3}


        // 我们可以对比下扩展运算符的方便之处
        // 以往我们是这样拼接数组的
        // let arr1 = [1, 2, 3]
        // let arr2 = [4, 5, 6]
        // let arr3 = arr1.concat(arr2)
        // console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]

        // 现在我们用扩展运算符看看
        // let arr1 = [1, 2, 3]
        // let arr2 = [4, 5, 6]
        // let arr3 = [...arr1, ...arr2]
        // console.log(arr3) // [ 1, 2, 3, 4, 5, 6 ]



    </script>
</body>

</html>